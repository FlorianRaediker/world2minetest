import argparse
import json
import random
import zlib

import numpy as np
import skimage.draw

from _util import le, SURFACES, DECORATIONS


def from_bytes(b):
    return int.from_bytes(b, "little")


HIGHWAY_WIDTHS = {
    "footway": 3,
    "service": 4,
    "cycleway": 3,
    "pedestrian": 3,
    "residential": 5,
    "path": 3,
    "primary": 6,
    "secondary": 6
}


def fit_array(a1, a1_min_x, a1_min_y, a2_min_x, a2_min_y, a2_size_x, a2_size_y):
    # fit array a1 into boundaries of a2
    offset_x = 0
    if a2_min_x < a1_min_x:
        offset_x = a1_min_x-a2_min_x
    elif a2_min_x > a1_min_x:
        a1 = a1[:, (a2_min_x-a1_min_x):]

    offset_y = 0
    if a2_min_y < a1_min_y:
        offset_y = a1_min_y-a2_min_y
    elif min_y > a1_min_y:
        a1 = a1[(a2_min_y-a1_min_y):, :]

    if a1.shape[1]+offset_x > a2_size_x:
        a1 = a1[:, :a2_size_x-offset_x]

    if a1.shape[0]+offset_y > a2_size_y:
        a1 = a1[:a2_size_y-offset_y, :]
    return a1, offset_x, offset_y


parser = argparse.ArgumentParser(description="Generate a map.dat file that can be read by world2minetest Mod")
parser.add_argument("--heightmap", type=argparse.FileType("rb"), help="Heightmap file generated by parse_heightmap_xyz.py", default=None)
parser.add_argument("--features", action="append", type=argparse.FileType("r"), help="features.json files generated by parse_features_osm.py or parse_features_dxf.json", default=None)
parser.add_argument("--incr", action="store_true", help="Add incremental map information to map.dat. Load new map data using the '/w2mt:incr' command. Use with caution and make a backup beforehand.")
parser.add_argument("--offsetx", type=int, help="EPSG:25832 x coordinate that will be x=0 in Minetest", default=None)
parser.add_argument("--offsetz", type=int, help="EPSG:25832 y coordinate that will be z=0 in Minetest (y is z in Minetest)", default=None)
parser.add_argument("--minx", type=int, help="Minimum EPSG:25832 x coordinate", default=None)
parser.add_argument("--maxx", type=int, help="Maximum EPSG:25832 x coordinate", default=None)
parser.add_argument("--miny", type=int, help="Minimum EPSG:25832 y coordinate (y is z in Minetest)", default=None)
parser.add_argument("--maxy", type=int, help="Maximum EPSG:25832 y coordinate (y is z in Minetest)", default=None)
parser.add_argument("--noheightreduction", action="store_true", help="Do not subtract the smallest height from every heightmap value")
parser.add_argument("--createimg", action="store_true", help="Create a .png visualization of every layer")
parser.add_argument("--verbose", "-v", action="store_true", help="More debug info")

args = parser.parse_args()

min_x = args.minx
max_x = args.maxx
min_y = args.miny
max_y = args.maxy

heightmap_file = args.heightmap
if heightmap_file is args.features is None:
    raise argparse.ArgumentTypeError("either --heightmap or --osm (or both) must be specified.")

heightmap = None
if heightmap_file is not None:
    heightmap_min_x = from_bytes(heightmap_file.read(4))
    heightmap_min_y = from_bytes(heightmap_file.read(4))
    heightmap_size_x = from_bytes(heightmap_file.read(2)) 
    heightmap_size_y = from_bytes(heightmap_file.read(2))

    min_x = min_x if min_x is not None else heightmap_min_x
    max_x = max_x if max_x is not None else (heightmap_min_x+heightmap_size_x-1)
    min_y = min_y if min_y is not None else heightmap_min_y
    max_y = max_y if max_y is not None else (heightmap_min_y+heightmap_size_y-1)

    heightmap = np.frombuffer(zlib.decompress(heightmap_file.read()), dtype=np.uint8).reshape((heightmap_size_y, heightmap_size_x))
    size = (max_x-min_x+1, max_y-min_y+1)
    heightmap, h_offset_x, h_offset_y = fit_array(heightmap, heightmap_min_x, heightmap_min_y, min_x, min_y, size[0], size[1])
else:
    heightmap = None


features = {
    "areas": [],
    "highways": [],
    "buildings": [],
    "decorations": []
}

def load_features_file(file):
    data = json.load(file)
    global min_x, max_x, min_y, max_y
    min_x = min_x if min_x is not None else data["min_x"]
    max_x = max_x if max_x is not None else data["max_x"]
    min_y = min_y if min_y is not None else data["min_y"]
    max_y = max_y if max_y is not None else data["max_y"]
    for key, value in features.items():
        value.extend(data.get(key, []))


for features_file in args.features:
    load_features_file(features_file)

size = (max_x-min_x+1, max_y-min_y+1)


print(f"from {min_x},{min_y} to {max_x},{max_y} (size: {size[0]},{size[1]})")
if min_x > max_x or min_y > max_y:
    raise ValueError("map size is invalid")

a = np.zeros((size[1], size[0], 3), dtype=np.uint8)


# HEIGHTMAP
if heightmap is not None:
    if not args.noheightreduction:
        sub = heightmap.min()
    else:
        sub = 0
    a[h_offset_y:h_offset_y+heightmap.shape[0]+1, h_offset_x:h_offset_x+heightmap.shape[1]+1, 0] = heightmap - sub


# FEATURES
def shift_coords(x_coords, y_coords):
    if type(x_coords) is list:
        x_res = []
        y_res = []
        for x, y in zip(x_coords, y_coords):
            if min_x <= x <= max_x and min_y <= y <= max_y:
                x = x-min_x
                y = y-min_y
                x_res.append(x)
                y_res.append(y)    
        return x_res, y_res
    x, y = x_coords, y_coords
    if min_x <= x <= max_x and min_y <= y <= max_y:
        return x-min_x, y-min_y
    return None, None

for area in features["areas"]:
    x, y = shift_coords(area["x"], area["y"])
    if len(x) < 3:
        if args.verbose: print("Too few coordinates, ignoring area:", x, y, area)
        continue
    surface = area["surface"]
    xx, yy = skimage.draw.polygon(x, y)
    a[yy, xx, 1] = SURFACES[surface]
    if surface in ("water", "pitch", "playground", "sports_centre", "parking"):
        a[yy, xx, 0] = int(round(a[yy, xx, 0].mean()))  # flatten area
    if surface in ("park", "village_green"):
        # add a bit of random grass
        random.seed(0)
        for x, y in zip(xx, yy):
            if random.random() < 0.025:
                a[y, x, 2] = DECORATIONS["grass"]
    else:
        a[yy, xx, 2] = 0  # if areas overlap, this removes any previously generated grass

for building in features["buildings"]:
    x_coords, y_coords = shift_coords(building["x"], building["y"])
    if len(x_coords) < 2:
        if args.verbose: print("Too few coordinates, ignoring building:", x_coords, y_coords, building)
        continue
    elif len(x_coords) == 2:
        xx, yy = skimage.draw.line(x_coords[0], y_coords[0], x_coords[1], y_coords[1])
    else:
        xx, yy = skimage.draw.polygon_perimeter(x_coords, y_coords)
    height = building.get("height")
    if height is None:
        height = building.get("levels")
        if height is not None:
            height *= 3
    if height is not None and building.get("is_part"):
        # only overwrite height if it is likely from the same building
        assert height >= 1
        a[yy, xx, 2] = 127 + height
    else:
        a[yy, xx, 2] = np.maximum(a[yy, xx, 2], 127 + (height or 1))
    a[yy, xx, 0] = int(round(a[yy, xx, 0].mean()))

for highway in features["highways"]:
    x_coords, y_coords = shift_coords(highway["x"], highway["y"])
    surface = highway["surface"]
    surface_id = SURFACES[surface]
    layer = highway.get("layer", 0)
    width = HIGHWAY_WIDTHS.get(highway["type"], 3)
    height = -layer*3 if layer < 0 else 0
    for i in range(0, len(x_coords)-1):
        x1, y1 = x_coords[i], y_coords[i]
        x2, y2 = x_coords[i+1], y_coords[i+1]
        xx, yy = skimage.draw.line(x1, y1, x2, y2)
        if width != 1:
            # very naive implementation for widths, improvement needed
            positions = set()
            if width == 3:
                for x, y in zip(xx, yy):
                    positions.update((
                                    (x, y+1),
                        (x-1, y),   (x, y  ),   (x+1, y),
                                    (x, y-1)
                    ))
            elif width == 4:
                for x, y in zip(xx, yy):
                    positions.update((
                        (x-1, y+1), (x  , y+1), (x+1, y+1),
                        (x-1, y  ), (x  , y  ), (x+1, y  ),
                        (x-1, y-1), (x  , y-1), (x+1, y-1)
                    ))
            elif width == 5:
                for x, y in zip(xx, yy):
                    positions.update((
                                                (x  , y+2),
                                    (x-1, y+1), (x  , y+1), (x+1, y+1),
                        (x-2, y  ), (x-1, y  ), (x  , y  ), (x+1, y  ), (x+2, y),
                                    (x-1, y-1), (x  , y-1), (x+1, y-1),
                                                (x  , y-2)
                    ))
            elif width == 6:
                for x, y in zip(xx, yy):
                    positions.update((
                                    (x-1, y+1), (x  , y+2), (x+1, y+2),
                        (x-2, y+1), (x-1, y+1), (x  , y+1), (x+1, y+1), (x+2, y+1),
                        (x-2, y  ), (x-1, y  ), (x  , y  ), (x+1, y  ), (x+2, y  ),
                        (x-2, y-1), (x-1, y-1), (x  , y-1), (x+1, y-1), (x+2, y-1),
                                    (x-1, y-2), (x  , y-2), (x+1, y+2),
                    ))
            xx = []
            yy = []
            for x, y in positions:
                if 0 <= x < size[0] and 0 <= y < size[1]:
                    xx.append(x)
                    yy.append(y)
        if height != 0:
            a[yy, xx, 0] = a[yy, xx, 0].mean() - height
        a[yy, xx, 1] = surface_id
        if layer >= 0:
            a[yy, xx, 2] = 0  # remove anything above the surface (buildings, randomly added grass)

for decoration in features["decorations"]:
    x, y = shift_coords(decoration["x"], decoration["y"])
    deco = decoration["type"]
    id_ = DECORATIONS[deco]
    if not x: # test if x is either None or []
        if args.verbose: print("Out of bounds, ignoring decoration:", x, y, decoration)
        continue
    if type(x) is list:
        for i in range(0, len(x)-1):
            x1, y1 = x[i], y[i]
            x2, y2 = x[i+1], y[i+1]
            xx, yy = skimage.draw.line(x1, y1, x2, y2)
            a[yy, xx, 2] = id_
    else:
        a[y, x, 2] = id_
    if deco == "tree":
        # place dirt below tree
        a[y, x, 1] = SURFACES["dirt"]


offset_x = args.offsetx-min_x if args.offsetx is not None else 0
offset_z = args.offsetz-min_y if args.offsetz is not None else 0

print("offset x:", offset_x, "offset z:", offset_z)

if args.incr:
    with open("world2minetest/map.dat", "rb") as f:
        old_offset_x = from_bytes(f.read(2))
        old_offset_z = from_bytes(f.read(2))
        old_size_x = from_bytes(f.read(2))
        old_size_y = from_bytes(f.read(2))
        length_a = from_bytes(f.read(4))
        old_a_ = np.frombuffer(zlib.decompress(f.read(length_a)), dtype=np.uint8).reshape((old_size_y, old_size_x, 3))

    old_a_, old_offset_x, old_offset_z = fit_array(old_a_, -old_offset_x, -old_offset_z, -offset_x, -offset_z, a.shape[1], a.shape[0])
    old_a = np.zeros(a.shape, dtype=np.uint8)
    old_a[old_offset_z:old_offset_z+old_a_.shape[0], old_offset_x:old_offset_x+old_a_.shape[1]] = old_a_

    diff = a != old_a
    
    changed_blocks = []

    block_x_start = -offset_x//16
    block_x_end = (-offset_x+a.shape[1])//16
    block_z_start = -offset_z//16
    block_z_end = (-offset_z+a.shape[0])//16
    for block_x in range(block_x_start, block_x_end+1):
        for block_z in range(block_z_start, block_z_end+1):
            z1 = max(block_z*16+offset_z, 0)
            z2 = min(z1+16, diff.shape[0])
            x1 = max(block_x*16+offset_x, 0)
            x2 = min(x1+16, diff.shape[1])
            if diff[z1:z2, x1:x2].any():
                changed_blocks.append((block_x, block_z))
    print(f"checking blocks from {block_x_start},{block_z_start} to {block_x_end},{block_z_end} for changes")
    print("changed blocks:", changed_blocks[:10], "..." if len(changed_blocks) > 10 else "")
    changed_blocks = zlib.compress(b"".join(le(np.uint16(x)) + le(np.uint16(z)) for x, z in changed_blocks), 9)
else:
    changed_blocks = b""


with open("world2minetest/map.dat", "wb") as f:
    f.write(le(np.uint16(offset_x)))
    f.write(le(np.uint16(offset_z)))
    f.write(le(np.uint16(a.shape[1])))
    f.write(le(np.uint16(a.shape[0])))
    a_compressed = zlib.compress(a.tobytes(), 9)
    f.write(le(np.uint32(len(a_compressed))))
    f.write(a_compressed)
    f.write(le(np.uint32(len(changed_blocks))))
    f.write(changed_blocks)

if args.createimg:
    import imageio

for i in range(3):
    layer = a[::-1,:,i]
    name = "layer" + ["0_height", "1_surface", "2_deco"][i]
    m = max(layer.max(), 1)
    print(name, "max value:", m)
    if args.createimg:
        imageio.imwrite(f"world2minetest/{name}.png", layer*int(255/m))
